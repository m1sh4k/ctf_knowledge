### add
Для сложения применяется инструкция add. Она принимает два операнда, складывает их и помещает результат в первый операнд. Сложим два числа.
```armasm
add operand1, operand2  ; operand1 = operand1 + operand2
mov rdi, 22
mov rsi, 11
add rdi, rsi    ; rdi = rdi + rsi = 22 + 11 = 33
```
### sub
Для вычитания применяется инструкция sub, которая также принимает два операнда, вычитает из первого операнда второй операнд и помещаем результат в первый операнд. 
```armasm
mov rdi, 23
mov rsi, 11
sub rdi, rsi    ; rdi = rdi - rsi = 23 - 11 = 12
```

### increment/decrement (inc/dec)
inc (для увеличивает на 1) и dec (уменьшает на 1). Эти инструкции принимают только один операнд, значение которого уменьшается/увеличивается.
```armasm
; increment
mov rdi, 23
inc rdi    ; rdi = rdi + 1 = 23 + 1 = 24

; decrement
mov rdi, 23
dec rdi    ; rdi = rdi - 1 = 23 - 1 = 22
```

### mul/imul
Инструкции mul и imul умножает два целых числа. imul умножает числа со знаком, а mul - беззнаковые числа. Обе инструкции принимают один операнд - регистр или адрес в памяти, который умножается на значение в регистре RAX. Результат помещается в регистры RAX/RDX:
```armasm
mul operand8   ; если операнд 8-разрядный, результат в AX
mul operand16  ; если операнд 16-разрядный, результат в DX:AX
mul operand32  ; если операнд 32-разрядный, результат в EDX:EAX
mul operand64  ; если операнд 64-разрядный, результат в RDX:RAX
```

Инструкция imul также может принимать два и три операнда:
```armasm
imul dest, source
imul dest, source, constant
```

### div/idiv

Для деления чисел в архитектуре x86-64 предназначены инструкции div и idiv. idiv делит два числа со знаком, а div - беззнаковые числа. Эти инструкции принимают следующие формы:
```armasm
div reg8
div reg16
div reg32
div reg64
 
div mem8
div mem16
div mem32
div mem64
 
idiv reg8
idiv reg16
idiv reg32
idiv reg64
 
idiv mem8
idiv mem16
idiv mem32
idiv mem64
```

Пример деления на Linux:
```armasm
global _start
 
section .text
_start:
    mov rax, 0  ; обнуляем регистр
    mov ax, 22  ; 16-разрядный регистр
    mov bl, 5   ; 8-разрядный регистр
    div bl      ; AX/BL = AL =4 (результат), AH = 2 (остаток)
    movzx rdi, al   ; RDI = 4
    mov rax, 60
    syscall
```

Перед делением целочисленных значений со знаком одинаковой разрядности с помощью idiv необходимо расширить знаком AL в AX (поместив знаковый бит числа в AH), AX в DX (знаковый бит в DX), EAX в EDX (знаковый бит в EDX) или RAX в RDX (знаковый бит в RDX). Для этого можно использовать следующие инструкции `cbw, cwd, cdq` или `cqo`

- cbw: преобразует байт в AL в слово в AX через расширение знаком
- cwd: преобразует 16-разрядное число в AX в 32-разрядное в DX:AX через расширение знаком
- cdq: преобразует 32-разрядное число в EAX в 64-разрядное в EDX:EAX с помощью расширения знаком
- cqo: преобразует 64-разрядное число в RAX в 128-разрядное в RDX:RAX через расширение знаком
- cwde: преобразует 16-разрядное число в AX в 32-разрядное в EAX с помощью расширения знаком
- cdqe: преобразует 32-разрядное число в EAX в 64-разрядное в RAX с помощью расширения знаком